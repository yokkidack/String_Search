# Описание программы

## Краткое описание логики
- Папка `tests` содержит юнит-тесты Алгоритмов поиска подстроки.
- Папка `demo` содержит маленький файл с демонстрацией использования алгоритмов.
- Функция Search из пространства имен Boyer_Moore пердоствляет функциональность поиска подстроки в строке алгоритмом Поиска подстроки Бойера - Мура. (Принимает: std::vector<char> `string` - строка, std::vector<char> `substring` - подстрока)
- Функция Search из пространства имен Boyer_Moore_bad пердоствляет функциональность поиска подстроки в строке алгоритмом Поиска подстроки Бойера - Мура используя только "правило плохих символов". (Принимает: std::vector<char> `string` - строка, std::vector<char> `substring` - подстрока)
- Функция Search из пространства имен Knut_Morris_Pratt пердоствляет функциональность поиска подстроки в строке алгоритмом Поиска подстроки Кнута — Морриса — Пратта. (Принимает: std::vector<char> `string` - строка, std::vector<char> `substring` - подстрока)
- Функция Search из пространства имен  Rabin_Karp пердоствляет функциональность поиска подстроки в строке алгоритмом Поиска подстроки Рабина - Карпа. (Принимает: std::vector<char> `string` - строка, std::vector<char> `substring` - подстрока)
- Функция Search из пространства имен Naive пердоствляет функциональность поиска подстроки в строке Наивным Алгоритмом поиска подстроки. (Принимает: std::vector<char> `string` - строка, std::vector<char> `substring` - подстрока)

<!--
Функция ААА отвечает за разбор и проверху входного файла...
Функция БББ из класса ВВВ инкапсулирует основной алгоритм: сначала делает то, потом се, по сусекам поскребет, по амбару пометет... потом ставит на окошко остудить.
Функция ГГГ отвечает за разгон колобков, которые были получены в функции БББ.
Папка абырвалг содержит юнит-тесты для алгоритмов Павлова
Функция ДДД содержит генератор занудности деда. При этом в ней используется особенность структуры "старые кости", чтобы лучше ныть.
-->
...

## Использованные структуры данных

Для хранения и передачи строк/подстрок я использовал std::vector<char>

Могу разделить работу с конетйнером на 3 части и обьяснить свой выбор.
`Во-первых`, при введении данных в программу мне заранее не известен размер данных, по этому вставка символов в динамический массив - вполне эффективное решение, не требующего многократного прохода массива входных данных. Например, если бы я решил воспользоваться контейнером фиксированной длины, то мне бы пришлось обходить входные данные чтобы определить их размер, что в некоторых случаях значительно увеличило время работы. В среднем вставка будет О(1).
`Во-вторых`, я передавал данные по ссылке и данные не копировались лишний раз, что сильно ускорило работу программы. Тесты показали что это увеличивает скорость в 1,5-2 раза.
`В-третьих`, я обхода мне требовалось получать значения по индексу. Контейнер std::vector позволяет получать доступ по индексу за О(1).

Почему не std::string?

У std::string есть множество специальных методов ля работы со строками, но как не парадоксально единственный интересный метод: std::string::find_first_of, но я реализую его сам.

У std::string есть SSO (Small String Optimization), но строки у меня намного больше во всех случаях, кроме пары тестов.

std::string и std::vector<char> в условиях моей задачи и тестов в почти идентичны, я выбрал из них вектор потому что:

    - в явном виде указывается тип "букв" в виде типов данных, а не в виде типов  контейнеров.

## Оценки - в теоретическом сравнении
