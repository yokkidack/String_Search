# Теоретическая часть

## Условие задачи


Реализуйте и сравните 3--5 различных алгоритмов поиска подстроки в строке.
Для каждого найдите условия, где он работает лучше всего.

## Подходы к решению задачи поиска подстроки

Задача поиска подстроки часто встречается в самых разных областях жизни.
Для решения различных прикладных задач было придуманно множество различных
алгоритмов поиска подстрок.
Задачи поиска подстроки обычно можно разделить на задачи вида "найти первое вхождение подстроки", "найти любое вхождение" и "найти все вхождения".

### Подходы к классификации алгоритмов поиска подстроки

Существует несколько классификаций алгоритмов. В научной литературе часто представляются следующие:

| № |                классификации                          |
|---|--------------------------------------------------------|
| 1.| классификация по количеству искомых подстрок           |
| 2.| классификация по наличию пре обработки строки/подстроки|
| 3.| классификация по стратегии                             |

1.  Классификация по количеству искомых подстрок

Данная классификация основана на количестве искомых подстрок (паттернов)

| № | класс                                          | описание класса                | Примеры |
|---|------------------------------------------------|---------------------------------|---------|
| 1.|  Алгоритмы поиска одного паттерна              | Подстрока или Паттерн всего один| [Наивный алгоритм](#naiv), [Алгоритм поиска подстроки Рабина - Карпа](#rk), [Алгоритм поиска строки Бойера — Мура](#bm), [Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)](#kmp), [Алгоритм поиска подстроки BNDM](#bndm) |
| 2.|  Алгоритмы поиска конечного числа паттернов    | Поиск происходит для конечного множества подстрок или паттернов | [Алгоритм Ахо — Корасик](#aho), Алгоритм поиска подстроки Рабина - Карпа (для нескольких подстрок),  [Алгоритм Ву - Манбера (Wu-Manber)](#wu)|
| 3.|  Алгоритмы поиска бесконечного числа паттернов | Поиск происходит для бесконечного множества подстрок или паттернов, паттерны не перечисляются, но для них используются [регулярные выражения](#regex) или [регулярная грамматика](#reggram) |  |

2.  Классификация по наличию пре обработки строки/подстроки

|                            |  Нет пре обработки строки  |  Есть пре обработка строки        |
|-----------------------------|-----------------------------|-----------------------------------|
| Нет пре обработки подстроки  | Элементарные алгоритмы      | [factor automata](#faco), индексные методы (index methods)  |
| Есть пре обработка подстроки | [pattern matching automata](#pma)  |  [pattern matching automata](#pma), [factor automata](#faco), подписные методы (signature methods)  |

| класс                                                        | пример                    |
|---------------------------------------------------------------|---------------------------|
| Элементарные алгоритмы                                        | [Наивный алгоритм](#naiv) |
| [factor automata](#faco)                                      ||
| индексные методы (index methods)                              ||
| [pattern matching automata](#pma)                            ||
| подписные методы (signature methods)                          | Модифицированные алгоритмы для поиска n-грамм вместо символов, [больше информации, примеры реализации и многое другое](#witold)|

3.  Классификация по стратегии  [*](#gonzalo)

| No | класс                                        | Примеры |
|---|-----------------------------------------------|---------|
| 1.|  Сопоставление по префиксу в первую очередь  | [Knuth-Morris-Pratt](#kmp), [Shift-And](#shand), [Aho-Corasick](#aho)
| 2.|  Сопоставление по суффиксу в первую очередь  |  [Boyer-Moore](#bm) and variants
| 3.|  Сопоставление по наилучшему критерию        |  [BNDM](#bndm), [BOM](#bom) |
| 4.|  Прочие                                      |  [Naive](#naiv), [Rabin-Karp](#rk)


Алгоритм поиска подстроки в стоке - алгоритм позволяющий определить факт вхождения подстроки в строку и также определить в случае вхождения позицию на которой находится искомая подстрока.

В научной литературе подстроку иногда называют иголкой или шаблоном.

Строку иногда называют стогом сена (haystack).

Некоторые Алгоритмы поиска подстроки требуют предварительных вычислений, некоторые нет.

Существует несколько семейств алгоритмов поиска подстроки, например:
- Алгоритмы основанные на сравнении как «чёрном ящике»
(я рассмотрю Наивный алгоритм из этого семейства) - Во всех этих алгоритмах сравнение строк является «чёрным ящиком». Это позволяет использовать стандартные функции сравнения участков памяти, зачастую оптимизированные на ассемблерном уровне под тот или иной процессор и не выдающие точки, в которой наступило несовпадение.
- Алгоритмы основанные на сравнении с начала. (я рассмотрю алгоритм Кнута-Морриса-Пратта) - Это семейство алгоритмов страдает невысокой скоростью на «хороших» данных, что компенсируется отсутствием регрессии на «плохих».
- Алгоритмы основанные на сравнении с конца (я рассмотрю алгоритм Бойера - Мура)- В этом семействе алгоритмов needle движется по haystack слева направо, но сравнение этих строк друг с другом проводится справа налево. Сравнение справа налево позволяет в случае несовпадения сдвинуть needle не на одну позицию, а на несколько.

Я также рассмотрю BNDM - алгоритм который сначала подбирает наилучшее совпадение.

[//]: # (Возможно, демонстрация ее трудности и NP-полноты)
[//]: # (Описание самого алгоритма,  его свойств, описание того, как алгоритмом решать задачу, достоинства и недостатки)
[//]: # (Примечание: формулы можно вставить так: $`a^b+3`$. Или так:)
[//]: # (```math)
[//]: # (X = Y \cdot Z + \frac{c}{2})
[//]: # (```)

### Формальная постановка задачи

### <a name="naiv">Наивный Алгоритм (Naïve pattern searching)</a>

Простейший алгоритм поиска подстроки.

`Суть:`

```
1. Пусть есть строка (TEXT[N]). Пусть есть подстрока (SUBTEXT[M]).
Пусть есть i, i = 0,(N-M).
2. Для каждого i поэлементно сравнивать элементы строки и подстроки.
3. Если при поэлементном сравнении подстроки с 0 до M элемента и
строки с i элемента до i+M элемента строки совпали, то будем считать,
что найдена позиция вхождения подстроки в строку.
```
Алгоритм можно представить в виде псевдокода:

```
#
# ПУСТЬ:
#
РАЗМЕР_СТРОКИ # Размер строки
РАЗМЕР_ПОДСТРОКИ # Размер подстроки
СТРОКА[0..N]
ПОДСТРОКА[0..M]
СДВИГ_СТРОКИ = 0
СДВИГ_ПОДСТРОКИ = 0
#
# ВЫПОЛНЕНИЕ:
#
Пока СДВИГ_СТРОКИ<=РАЗМЕР_СТРОКИ-РАЗМЕР_ПОДСТРОКИ делать:
    Если СДВИГ_СТРОКИ = РАЗМЕР_СТРОКИ-РАЗМЕР_ПОДСТРОКИ то
        Вхождений больше искать нет смысла, строка кончилась
        ЗАКОНЧИТЬ_ЦИКЛ
    СДВИГ_ПОДСТРОКИ=0
    Пока СДВИГ_ПОДСТРОКИ<=РАЗМЕР_ПОДСТРОКИ и ПОДСТРОКА[СДВИГ_ПОДСТРОКИ] = СТРОКА[СДВИГ_СТРОКИ+СДВИГ_ПОДСТРОКИ] делать:
        Усли СДВИГ_ПОДСТРОКИ = РАЗМЕР_ПОДСТРОКИ то
            Найдено вхождение подстроки
            СДВИГ_СТРОКИ + 1
            ЗАКОНЧИТЬ_ЦИКЛ
        Иначе
            СДВИГ_ПОДСТРОКИ + 1

```



`Сложность` алгоритма О(N*M),
*где N - длина строки, а M - длина подстроки.*

Алгоритм не требует предворительных вычислений.

### <a name="rk">Алгоритм поиска подстроки Рабина - Карпа (Rabin-Karp Algorithm)</a>

Алгоритм поиска подстроки, использующий хэширование.

Алгоритм предложен Михаэлем Ошерем Рабином и Ричардом Мэннингом Карпом в статье [Rabin M. O., Karp R. M. Efficient randomized pattern-matching algorithms // IBM Journal of Research and Development. — IBM, 1987.] в 1987 году.

Сложность алгоритма (при выборе хорошей хэш-функции) О(n),
*где n - длина строки.*

Алгоритм требует только предворительного вычисления хэша подстроки.

### <a name="bm">Алгоритм поиска строки Бойера — Мура (Boyer–Moore string-search algorithm)</a>

Алгоритм поиска строки Бойера - Мура считается наиболее быстрым алгоритмом общего назначения, предназначенного для поиска подстроки в строке.

Алгоритм был разработан Робертом Стефаном Бойером и Джеем Штрофером Муром в 1977 году.  Преимущество этого алгоритма в том, что ценой некоторого количества предварительных вычислений над шаблоном (но не над строкой, в которой ведётся поиск) шаблон сравнивается с исходным текстом не во всех позициях — часть проверок пропускаются как заведомо не дающие результата.

Сложность алгоритма:

О(n+m) - если не используется таблица стоп символов.
O(n+m+|a|) - если используется таблица стоп символов.

*где:
n - длина строки
m - длина подстроки
|a| - мощность алфавита*

Алгоритм требует предворительных вычислений таблицы суффиксов и, если она используется, таблицы стоп символов

    Составление таблицы стоп символов требует:

    О(|a|) дополнительной памяти и
    О(|a|) дополнительного времени на этапе предворительных вычислений.

    Составление таблицы суффиксов требует:

    О(m) дополнительной памяти и
    О(m) дополнительного времени на этапе предворительных вычислений.

### <a name="kmp">Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм) (Knuth–Morris–Pratt string-searching algorithm)</a>

Алгоритм Кнута — Морриса — Пратта - эффективный алгоритм, осуществляющий поиск подстроки в строке. Время работы алгоритма линейно зависит от объёма входных данных, то есть разработать асимптотически более эффективный алгоритм невозможно.

Алгоритм был разработан Дональдом Эрвином Кнутом и Воном Рональдом Праттом и, независимо от них, Джеймсом Хирамом Моррисом. Результаты своей работы они опубликовали совместно в 1977 году.

### <a name="bndm">Алгоритм поиска подстроки BNDM (Backward Nondeterministic Dawg Matching algorithm)</a>

Этот алгоритм относится к классу поиска подстроки обратного обхода.

Алгоритм BNDM использует таблицу B, в которой для каждого символа хранится битовая маска. Маска Bi хранит значение тогда и только тогда когда xi = c.

Состояние поиска сохраняется в слове d = dm-1 .. d0, где длина шаблона m меньше или равна размеру машинного слова.
Бит di на итерации k устанавливается только в том случае, если x [m-i .. m-1-i + k] = y [j + m-k ... j + m-1]. На итерации 0 d устанавливается в 1m-1. Формула для обновления d следует d '= (d & B [yj]) << 1.
Соответствие существует тогда и только тогда, когда после итерации m оно имеет значение dm-1 = 1.
Всякий раз, когда dm-1 = 1, алгоритм сопоставляет префикс шаблона в текущей позиции окна j. Самый длинный совпадающий префикс дает переход к следующей позиции.

## Выбор алгоритма

- Наивный алгоритм я выбрал потому что с ним легко сравнивать все остальные. Он самый простой и "глупый", по этому на его фоне хорошо покажут себя его улучшения.
- Алгоритм Рабина карпа я выбрал потому что он выделяется на фоне остальных алгоритмов, про которые я читал необычной механикой - использованием хэшей. Мне было интересно рассмотреть такой подход.
- Алгоритм поиска строки Бойера - Мура я выбрал потому, что его:
- - Используют как эталон для оценки алгоритмов поиска подстроки в научной литературе [*](#hume)
- - Часто используют для функций "поиск" и "замена" в текстовых редакторах
- Алгоритм КМП был выбран из-за того, что его используют биоинформатике в решении "alignment problem" (на сколько я понял, суть задачи заключается в поиске участка генома в базе геномов, искомая подстрока порядка 100 тысяч знаков, база миллионы - миллиарды знаков).

### Дополнительные ссылки

1. <a name="wu"> Wu S. and U.Manber, “A Fast Algorithm for MultiPattern Searching,” Technical Report TR-94-17 Department of Computer Science, University of Arizona, Tucson, AZ (May 1994).</a>
2. <a name="witold">WRiad Mokadem; Witold Litwin (2007), Fast nGramBased String Search Over Data Encoded Using Algebraic Signatures, 33rd International Conference on Very Large Data Bases (VLDB) [link](http://www.cse.scu.edu/~tschwarz/Papers/vldb07_final.pdf)</a>
3. <a name="gonzalo">Navarro, Gonzalo & Raffinot, Mathieu. (2002). Flexible pattern matching in strings. Practical on-line search algorithms for texts and biological sequences. 10.1017/CBO9781316135228.</a>
4. <a name="bom">Christian Charras, Thierry LecroqBackward. Oracle Matching algorithm [link](https://www-igm.univ-mlv.fr/~lecroq/string/bom.html)</a>
5. <a name="shand">Wikipedia contributors. (2018, January 12). Bitap algorithm. In Wikipedia, The Free Encyclopedia. Retrieved 14:29, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Bitap_algorithm&oldid=820002037</a>
6. <a name="aho">Wikipedia contributors. (2019, November 2). Aho–Corasick algorithm. In Wikipedia, The Free Encyclopedia. Retrieved 14:30, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Aho%E2%80%93Corasick_algorithm&oldid=924182120</a>
7. <a name="reggram">Wikipedia contributors. (2019, September 8). Regular grammar. In Wikipedia, The Free Encyclopedia. Retrieved 14:31, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Regular_grammar&oldid=914589018</a>
8. <a name="regex">Wikipedia contributors. (2019, December 2). Regular expression. In Wikipedia, The Free Encyclopedia. Retrieved 14:32, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Regular_expression&oldid=928849112</a>
9. <a name="hume">Hume; Sunday (1991). "Fast String Searching". Software: Practice and Experience. 21 (11): 1221–1248. doi:10.1002/spe.4380211105 {https://doi.org/10.1002%2Fspe.4380211105}</a>
10. <a name="faco">Wikipedia contributors. (2019, August 15). Factor oracle. In Wikipedia, The Free Encyclopedia. Retrieved 14:34, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Factor_oracle&oldid=910966476</a>
11. <a name="pma">http://www-igm.univ-mlv.fr/~mac/REC/B4.html</a>
