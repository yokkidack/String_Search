# Теоретическая часть

## Условие задачи

Реализуйте и сравните 3--5 различных алгоритмов поиска подстроки в строке.
Для каждого найдите условия, где он работает лучше всего.

### Формальная постановка задачи

1. Выбрать 3-4 алгоритмов поиска подстроки в строке.
2. Описать выбранные алгоритмы.
3. Сравнить теоретически выбранные алгоритмы.
4. Реализовать выбранные алгоритмы поиска подстроки в строке.
5. Составить тесты для проверки реализованных алгоритмов на работоспособность.
6. Сравнить реализованные алгоритмы на практике.

## Подходы к решению задачи поиска подстроки

Задача поиска подстроки часто встречается в самых разных областях жизни.
Для решения различных прикладных задач было придумано множество различных
алгоритмов поиска подстрок.
Задачи поиска подстроки обычно можно разделить на задачи вида "найти первое вхождение подстроки", "найти любое вхождение" и "найти все вхождения".

### Подходы к классификации алгоритмов поиска подстроки

Существует несколько классификаций алгоритмов. В научной литературе часто представляются следующие:

| № |                классификации                           |
|---|--------------------------------------------------------|
| 1.| классификация по количеству искомых подстрок           |
| 2.| классификация по наличию пре обработки строки/подстроки|
| 3.| классификация по стратегии                             |

1.  Классификация по количеству искомых подстрок

Данная классификация основана на количестве искомых подстрок (паттернов)

| № | класс                                          | описание класса                | Примеры |
|---|------------------------------------------------|---------------------------------|---------|
| 1.|  Алгоритмы поиска одного паттерна              | Подстрока или Паттерн всего один| [Наивный алгоритм](#naiv), [Алгоритм поиска подстроки Рабина - Карпа](#rk), [Алгоритм поиска строки Бойера — Мура](#bm), [Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)](#kmp), [Алгоритм поиска подстроки BNDM](#bndm) |
| 2.|  Алгоритмы поиска конечного числа паттернов    | Поиск происходит для конечного множества подстрок или паттернов | [Алгоритм Ахо — Корасик](#aho), Алгоритм поиска подстроки Рабина - Карпа (для нескольких подстрок),  [Алгоритм Ву - Манбера (Wu-Manber)](#wu)|
| 3.|  Алгоритмы поиска бесконечного числа паттернов | Поиск происходит для бесконечного множества подстрок или паттернов, паттерны не перечисляются, но для них используются [регулярные выражения](#regex) или [регулярная грамматика](#reggram) |  |

2.  Классификация по наличию пре обработки строки/подстроки

|                            |  Нет пре обработки строки  |  Есть пре обработка строки        |
|-----------------------------|-----------------------------|-----------------------------------|
| Нет пре обработки подстроки  | Элементарные алгоритмы      | [factor automata](#faco), индексные методы (index methods)  |
| Есть пре обработка подстроки | [pattern matching automata](#pma)  |  [pattern matching automata](#pma), [factor automata](#faco), подписные методы (signature methods)  |

| класс                                                        | пример                    |
|---------------------------------------------------------------|---------------------------|
| Элементарные алгоритмы                                        | [Наивный алгоритм](#naiv) |
| [factor automata](#faco)                                      ||
| индексные методы (index methods)                              ||
| [pattern matching automata](#pma)                            ||
| подписные методы (signature methods)                          | Модифицированные алгоритмы для поиска n-грамм вместо символов, [больше информации, примеры реализации и многое другое](#witold)|

3.  Классификация по стратегии  [*](#gonzalo)

| № | класс                                        | Примеры |
|---|-----------------------------------------------|---------|
| 1.|  Сопоставление по префиксу в первую очередь  | [Knuth-Morris-Pratt](#kmp), [Shift-And](#shand), [Aho-Corasick](#aho)
| 2.|  Сопоставление по суффиксу в первую очередь  |  [Boyer-Moore](#bm) and variants
| 3.|  Сопоставление по наилучшему критерию        |  [BNDM](#bndm), [BOM](#bom) |
| 4.|  Прочие                                      |  [Naive](#naiv), [Rabin-Karp](#rk)


Алгоритм поиска подстроки в стоке - алгоритм позволяющий определить факт вхождения подстроки в строку и также определить в случае вхождения позицию на которой находится искомая подстрока.

В научной литературе подстроку иногда называют иголкой или шаблоном.

Строку иногда называют стогом сена (haystack).

Некоторые Алгоритмы поиска подстроки требуют предварительных вычислений, некоторые нет.

Существует несколько семейств алгоритмов поиска подстроки, например:
- Алгоритмы основанные на сравнении как «чёрном ящике»
(я рассмотрю Наивный алгоритм из этого семейства) - Во всех этих алгоритмах сравнение строк является «чёрным ящиком». Это позволяет использовать стандартные функции сравнения участков памяти, зачастую оптимизированные на ассемблерном уровне под тот или иной процессор и не выдающие точки, в которой наступило несовпадение.
- Алгоритмы основанные на сравнении с начала. (я рассмотрю алгоритм Кнута-Морриса-Пратта) - Это семейство алгоритмов страдает невысокой скоростью на «хороших» данных, что компенсируется отсутствием регрессии на «плохих».
- Алгоритмы основанные на сравнении с конца (я рассмотрю алгоритм Бойера - Мура)- В этом семействе алгоритмов needle движется по haystack слева направо, но сравнение этих строк друг с другом проводится справа налево. Сравнение справа налево позволяет в случае несовпадения сдвинуть needle не на одну позицию, а на несколько.

[//]: # (Возможно, демонстрация ее трудности и NP-полноты)
[//]: # (Описание самого алгоритма,  его свойств, описание того, как алгоритмом решать задачу, достоинства и недостатки)
[//]: # (Примечание: формулы можно вставить так: $`a^b+3`$. Или так:)
[//]: # (```math)
[//]: # (X = Y \cdot Z + \frac{c}{2})
[//]: # (```)

### <a name="naiv">Наивный Алгоритм (Naïve pattern searching)</a>

Простейший алгоритм поиска подстроки.

`Суть:`

```
1. Пусть есть строка (TEXT[N]). Пусть есть подстрока (SUBTEXT[M]).
Пусть есть i, i = от 0 до (N-M).
2. Для каждого i поэлементно сравнивать элементы строки и подстроки.
3. Если при поэлементном сравнении подстроки с 0 до M элемента и
строки с i элемента до i+M элемента строки совпали, то будем считать,
что найдена позиция вхождения подстроки в строку.
```
Алгоритм можно представить в виде псевдокода:

```
#
# ПУСТЬ:
#
РАЗМЕР_СТРОКИ # Размер строки
РАЗМЕР_ПОДСТРОКИ # Размер подстроки
СТРОКА[0..РАЗМЕР_СТРОКИ]
ПОДСТРОКА[0..РАЗМЕР_ПОДСТРОКИ]
СДВИГ_СТРОКИ = 0
СДВИГ_ПОДСТРОКИ = 0
#
# ВЫПОЛНЕНИЕ:
#
Пока СДВИГ_СТРОКИ<=РАЗМЕР_СТРОКИ-РАЗМЕР_ПОДСТРОКИ делать:
    Если СДВИГ_СТРОКИ = РАЗМЕР_СТРОКИ-РАЗМЕР_ПОДСТРОКИ то
        Вхождений больше искать нет смысла, строка кончилась
        ЗАКОНЧИТЬ_ЦИКЛ
    СДВИГ_ПОДСТРОКИ=0
    Пока СДВИГ_ПОДСТРОКИ<=РАЗМЕР_ПОДСТРОКИ и ПОДСТРОКА[СДВИГ_ПОДСТРОКИ] = СТРОКА[СДВИГ_СТРОКИ+СДВИГ_ПОДСТРОКИ] делать:
        Если СДВИГ_ПОДСТРОКИ = РАЗМЕР_ПОДСТРОКИ то
            Найдено вхождение подстроки
            СДВИГ_СТРОКИ + 1
            ЗАКОНЧИТЬ_ЦИКЛ
        Иначе
            СДВИГ_ПОДСТРОКИ + 1

```



`Сложность` алгоритма О(N*M),
*где N - длина строки, а M - длина подстроки.*

Алгоритм не требует предварительных вычислений.

### <a name="rk">Алгоритм поиска подстроки Рабина - Карпа (Rabin-Karp Algorithm)</a>

Алгоритм поиска подстроки, использующий хэширование.

Алгоритм предложен Михаэлем Ошерем Рабином и Ричардом Мэннингом Карпом в статье [Rabin M. O., Karp R. M. Efficient randomized pattern-matching algorithms // IBM Journal of Research and Development. — IBM, 1987.] в 1987 году.

`Суть:`

```
1. Пусть есть строка (TEXT[N]). Пусть есть подстрока (SUBTEXT[M]).
Пусть есть i, i = от 0 до (N-M). И HASH_SUBTEXT = HASH(SUBTEXT)
2. Для каждого i поэлементно сравнивать элементы HASH_SUBTEXT и HASH(подстроки TEXT c i по i+m элемент).
3. Если хэши равны, то и SUBTEXT равна подстроке строки TEXT, значит найдена позиция вхождения = i
```

Алгоритм поиска можно представить в виде псевдокода:
```
#
# ПУСТЬ:
#
РАЗМЕР_СТРОКИ # Размер строки
РАЗМЕР_ПОДСТРОКИ # Размер подстроки
СТРОКА[0..РАЗМЕР_СТРОКИ]
ПОДСТРОКА[0..РАЗМЕР_ПОДСТРОКИ]
СДВИГ_СТРОКИ = 0
СДВИГ_ПОДСТРОКИ = 0
НЕКОТОРОЕ_ПРОСТОЕ_ЧИСЛО
ДЛИНА_АЛФАВИТА
БАЗА_ХЭША = ( ДЛИНА_АЛФАВИТА ^ (РАЗМЕР_ПОДСТРОКИ - 1) ) mod НЕКОТОРОЕ_ПРОСТОЕ_ЧИСЛО
#
# ПРЕ ОБРАБОТКА:
#
ХЭШ_ПОДСТРОКИ = ХЭШ(ПОДСТРОКА)
#
# ПОИСК:
#
ИТЕРАТОР = 0
Для ИТЕРАТОР от 0 до РАЗМЕР_СТРОКИ - РАЗМЕР_ПОДСТРОКИ делать
    ХЭШ_ОКНА(СТРОКА[ИТЕРАТОР..ИТЕРАТОР-РАЗМЕР_ПОДСТРОКИ+1])
    Если ХЭШ_ОКНА = ХЭШ_ПОДСТРОКИ
        Найдено соответствие в позиции = ИТЕРАТОР
        Закончить
Соответствие не найдено
```

Сложность поиска в алгоритме (при выборе хорошей хэш-функции) О(n),
*где n - длина строки.*

Алгоритм требует только предварительного вычисления хэша подстроки.
Он считается за O(m)
### <a name="bm">Алгоритм поиска строки Бойера — Мура (Boyer–Moore string-search algorithm)</a>

Алгоритм поиска строки Бойера - Мура считается наиболее быстрым алгоритмом общего назначения, предназначенного для поиска подстроки в строке.

Алгоритм проходит подстроку (паттерн) с права на лево, начина с самого правого символа.

Алгоритм был разработан Робертом Стефаном Бойером и Джеем Штрофером Муром в 1977 году.  Преимущество этого алгоритма в том, что ценой некоторого количества предварительных вычислений над шаблоном (но не над строкой, в которой ведётся поиск) шаблон сравнивается с исходным текстом не во всех позициях — часть проверок пропускаются как заведомо не дающие результата.

Сложность алгоритма:

О(n+m) - если не используется таблица стоп символов.
O(n+m+|a|) - если используется таблица стоп символов.

*где:
n - длина строки
m - длина подстроки
|a| - мощность алфавита*

Алгоритм требует предварительных вычислений таблицы суффиксов и, если она используется, таблицы стоп символов

    Составление таблицы стоп символов требует:

    О(|a|) дополнительной памяти и
    О(|a|) дополнительного времени на этапе предварительных вычислений.

    Составление таблицы суффиксов требует:

    О(m) дополнительной памяти и
    О(m) дополнительного времени на этапе предварительных вычислений.

Таблица стоп символов иногда называется таблицей плохих символов.

При обходе строки с лева на право, окно строки сравнивается с подстрокой справа на лево, в случае нахождения расхождения элементов подстроки и строки, вместо того чтобы сдвигаться на один элемент, как это делалось бы в Наивном алгоритме, происходит сдвиг по таблице плохих символов.

Таблица плохих символов составляется во време пре обработки.

Я представлю способ для определения таблицы плохих символов требующий O(m) дополнительной памяти, однако есть и [другой способ](#badchar), требующий O(m*p) памяти, вычисление которого более наглядное, но рассматривать его я не буду.
Выделяется массив размера равного размеру алфавита строки.

Вычисление таблицы:
```
Пусть:

i = 0 - итератор
РАЗМЕР_АЛФАВИТА - размер алфавита слова
ТАБЛИЦА_ПЛОХИХ_СИМВОЛОВ[0...PАЗМЕР_АЛФАВИТА-1]
m - размер подслова
A[0...m-1] - подслово

Вычисление:

пока (i < РАЗМЕР_АЛФАВИТА) делать
    ТАБЛИЦА_ПЛОХИХ_СИМВОЛОВ[i] = m
    i = i + 1
пока (i < m - 1) делать
    ТАБЛИЦА_ПЛОХИХ_СИМВОЛОВ[A[i]] = m - i - 1
    i = i + 1
```
Поиск:
```
m - размер подслова
A[0...m-1] - подслово
n - размер слова
B[0...n-1] - слово
ТПС[0...PАЗМЕР_АЛФАВИТА-1] - Таблица плохих символов.
j, i - итераторы

пока (j <= n-m) делать:
    пусть i = m - 1
    пока (i >= 0) и (A[i] == B[i+j]) делать:
        i= i - 1
    если ( i < 0 ) то найдено вхождение подслова в слове, индекс = j
    иначе j = ТПС[i+j] - m + i - 1
если цикл закончился и вхождений не найдено, то подслово не найдено вхождение
```
### <a name="kmp">Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм) (Knuth–Morris–Pratt string-searching algorithm)</a>

Алгоритм Кнута — Морриса — Пратта - эффективный алгоритм, осуществляющий поиск подстроки в строке. Время работы алгоритма линейно зависит от объёма входных данных, то есть разработать асимптотически более эффективный алгоритм невозможно.
Алгоритм Кнута - Морриса - Притта основан на [Алгоритме Морриса - Пратта](#km), который в свою очередь является улучшением Наивного алгоритма. [*](#kmkmp)

Для дальнейшего рассказа об алгоритме КМП введу следующие понятия:

префикс - подстрока некоторой строки A[0...n], которая начинается с A[0] и заканчивается некоторым A[i]

суффикс - подстрока некоторой строки A[0...n], которая начинается с некоторого A[i] и заканчивается A[n]

При обходе строки в Наивном Алгоритме если на некотором шаге проверки букв подстроки с буквами строки на соответствие обнаруживается несоответствие, то приходится возвращаться и начинать проверку на соответствие с самого начала подстроки и с элемента последующего тому с которого начиналась проверка на предыдущем шаге.

Основная идея Алгоритма Кнута — Морриса — Пратта - `уменьшение расстояния на который приходится возвращаться при нахождении несоответствия букв строки и подстроки`.

Алгоритм Кнута — Морриса — Пратта достигает этого с помощью специальной таблицы, pi (или kmpNext), такой что:
kmpNext[i] равна длине наибольшей границы, в подстроке A[0...m], A[0..i-1], после которой идет символ отличный от A[i] или -1, если такой границы нет. 1 < i <= m. kmpNext[0] = -1

С помощью этой таблицы при обнаружении несоответствия, можно переходить к сравнению элементов подстроки A[0...m] и строки B[0...n], на шаге i=i+1, вместо перехода к сравнению с A[i] и B[i], к сравнению с A[kmpNext[i]] и B[i+j]



```
Пусть:
n - длина строки
m- длина подстроки
kmpNext - таблица переходов
i - итератор
Для i от 0 до n - 1 делать:
    Если kmpNext[m + i + 1] == m то
        найдено вхождение
```
[//]: # (элегантное описание, понравилось)
[//]: # (https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Кнута-Морриса-Пратта)

Алгоритм был разработан Дональдом Эрвином Кнутом и Воном Рональдом Праттом и, независимо от них, Джеймсом Хирамом Моррисом. Результаты своей работы они опубликовали совместно в 1977 году.

## Выбор алгоритма

- Наивный алгоритм я выбрал потому что с ним легко сравнивать все остальные. Он самый простой и "глупый", по этому на его фоне хорошо покажут себя его улучшения.
- Алгоритм Рабина карпа я выбрал потому что он выделяется на фоне остальных алгоритмов, про которые я читал необычной механикой - использованием хэшей. Мне было интересно рассмотреть такой подход.
- Алгоритм поиска строки Бойера - Мура я выбрал потому, что его:
- - Используют как эталон для оценки алгоритмов поиска подстроки в научной литературе [*](#hume)
- - Часто используют для функций "поиск" и "замена" в текстовых редакторах
- Алгоритм КМП был выбран из-за того, что его используют биоинформатике в решении "alignment problem" (на сколько я понял, суть задачи заключается в поиске участка генома в базе геномов, искомая подстрока порядка 100 тысяч знаков, база миллионы - миллиарды знаков).

### Дополнительные ссылки

1. <a name="wu"> Wu S. and U.Manber, “A Fast Algorithm for MultiPattern Searching,” Technical Report TR-94-17 Department of Computer Science, University of Arizona, Tucson, AZ (May 1994).</a>
2. <a name="witold">WRiad Mokadem; Witold Litwin (2007), Fast nGramBased String Search Over Data Encoded Using Algebraic Signatures, 33rd International Conference on Very Large Data Bases (VLDB) [link](http://www.cse.scu.edu/~tschwarz/Papers/vldb07_final.pdf)</a>
3. <a name="gonzalo">Navarro, Gonzalo & Raffinot, Mathieu. (2002). Flexible pattern matching in strings. Practical on-line search algorithms for texts and biological sequences. 10.1017/CBO9781316135228.</a>
4. <a name="bom">Christian Charras, Thierry Lecroq. Oracle Matching algorithm [link](https://www-igm.univ-mlv.fr/~lecroq/string/bom.html)</a>
5. <a name="shand">Wikipedia contributors. (2018, January 12). Bitap algorithm. In Wikipedia, The Free Encyclopedia. Retrieved 14:29, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Bitap_algorithm&oldid=820002037</a>
6. <a name="aho">Wikipedia contributors. (2019, November 2). Aho–Corasick algorithm. In Wikipedia, The Free Encyclopedia. Retrieved 14:30, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Aho%E2%80%93Corasick_algorithm&oldid=924182120</a>
7. <a name="reggram">Wikipedia contributors. (2019, September 8). Regular grammar. In Wikipedia, The Free Encyclopedia. Retrieved 14:31, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Regular_grammar&oldid=914589018</a>
8. <a name="regex">Wikipedia contributors. (2019, December 2). Regular expression. In Wikipedia, The Free Encyclopedia. Retrieved 14:32, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Regular_expression&oldid=928849112</a>
9. <a name="hume">Hume; Sunday (1991). "Fast String Searching". Software: Practice and Experience. 21 (11): 1221–1248. doi:10.1002/spe.4380211105 {https://doi.org/10.1002%2Fspe.4380211105}</a>
10. <a name="faco">Wikipedia contributors. (2019, August 15). Factor oracle. In Wikipedia, The Free Encyclopedia. Retrieved 14:34, December 2, 2019, from https://en.wikipedia.org/w/index.php?title=Factor_oracle&oldid=910966476</a>
11. <a name="pma">M. Crochemore and C. Hancart, Automata for matching patterns, in (Handbook of Formal Languages, G. Rosenberg and A. Salomaa, eds., volume 2, Linear Modeling, Springer-Verlag, 1997) pp 399-462. http://www-igm.univ-mlv.fr/~mac/REC/B4.html</a>
12. <a name="kmkmp">http://algolist.manual.ru/search/esearch/mp.php</a>
13. <a name="km">Christian Charras, Thierry Lecroq. Morris Pratt algorithm https://www-igm.univ-mlv.fr/~lecroq/string/node7.html</a>
14. <a name="badchar"> Лекция: ADS1: Boyer-Moore: putting it all together https://youtu.be/Wj606N0IAsw</a>
